#! /usr/bin/env bash

DEV_NAME=ttyUSB0

WATCH=false
BUILD=false
INSTALL=false
CONTAINER=false
TEST_XML=false
TEST_WATCH=false

function usage {
  echo "'run' generates build system files and installs builds."
  echo ""
  echo "Usage: start [<command>]"
  echo ""
  echo "  watch            runs binary in watch mode inside a new container process (run on host)"
  echo "  build            builds src (run inside container)"
  echo "  install          installs built src (run inside container)"
  echo "  container        builds and pushes the dev envireonment Docker container (run on host)"
  echo "  test-xml         tests xml schema in watch mode"
  echo "  test-watch       run tests in watch mode"
}

function build {
  cmake -S . -B build     # generate build files
  cmake --build build -v  # build src from build files
}

function install {
  cmake --install build  # install built src (CMake 3.15+ only)
}

function run_shell {
  # NOTES:
  # the libmonome code (particularly for platform/linux_libudev) tries to resolve some
  # ENV properties on the udev device-- specifically ID_SERIAL_SHORT. If run on the host
  # machine, this property will be available, but inside the Docker container, this property
  # (along with all other ID_* properties are stripped from the udev info
  # (see with udevadm info /dev/ttyUSB0 for example)). So the work around is to mount a read-only
  # volume of the udev data (at /run/udev) into the container so that it has access to all the data.
  docker run \
         -it \
         --rm \
         --privileged \
         --pull always \
         -v "$PWD":/grid \
         -v /run/udev:/run/udev:ro \
         --device=/dev/$DEV_NAME:/dev/$DEV_NAME \
         ghcr.io/asmr-hex/grid/dev:latest \
         /bin/bash
}

function run_watch {
  docker run \
         -it \
         --rm \
         --privileged \
         --pull always \
         -v "$PWD":/grid \
         -v /run/udev:/run/udev:ro \
         --device=/dev/$DEV_NAME:/dev/$DEV_NAME \
         ghcr.io/asmr-hex/grid/dev:latest \
         nodemon -L --watch src --exec "make run || exit 1" --ext hpp,cpp,h,c
}

function unittest_watch {
  nodemon -L \
          --watch src/ \
          --watch tests/unit \
          --watch include/ \
          --exec "cmake -S . -B build && cmake --build build && cmake --build build -t test || exit 1" \
          --ext '*'
}

function test_xml {
  docker run \
         -it \
         --rm \
         --privileged \
         --pull always \
         -v "$PWD":/grid \
         -v /run/udev:/run/udev:ro \
         --device=/dev/$DEV_NAME:/dev/$DEV_NAME \
         ghcr.io/asmr-hex/grid/dev:latest \
         nodemon -L --watch schema.xsd --watch conf-xml/test.xml --exec "xmllint --noout --schema schema.xsd conf-xml/test.xml || exit 1" --ext xml,xsd
}

function build_and_push_container {
  # build container image
  docker build -t ghcr.io/asmr-hex/grid/dev:latest -f dockerfiles/dev .

  # login to github container registry
  pass show github/registry | docker login ghcr.io --username asmr-hex --password-stdin

  # push to github container registry
  docker push ghcr.io/asmr-hex/grid/dev:latest
}

function run {
  if [ "$CONTAINER" = true ]
  then
    build_and_push_container
    exit 0
  fi

  # run install if specified
  if [ "$BUILD" = true ]
  then
    build
    exit 0
  fi

  # run install if specified
  if [ "$INSTALL" = true ]
  then
    install
    exit 0
  fi

  if [ "$WATCH" = true ]
  then
    run_watch
    exit 0
  fi

  if [ "$TEST_XML" = true ]
  then
    test_xml
    exit 0
  fi

  if [ "$TEST_WATCH" = true ]
  then
    unittest_watch
    exit 0
  fi


  run_shell
}

function parse_args {
  while [[ $# -gt 0 ]]
  do
    local next_arg="$1"
    case $next_arg in
      -h|--help)
        usage
        exit 0
        ;;
      build)
        BUILD=true
        shift
        ;;
      install)
        INSTALL=true
        shift
        ;;
      container)
        CONTAINER=true
        shift
        ;;
      watch)
        WATCH=true
        shift
        ;;
      test-xml)
        TEST_XML=true
        shift
        ;;
      test-watch)
        TEST_WATCH=true
        shift
        ;;
    esac
  done
}

parse_args $@
run
