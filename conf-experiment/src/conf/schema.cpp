// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "schema.hpp"

// name
// 


// Interface
// 

const Interface::Outputs_optional& Interface::
Outputs () const
{
  return this->Outputs_;
}

Interface::Outputs_optional& Interface::
Outputs ()
{
  return this->Outputs_;
}

void Interface::
Outputs (const Outputs_type& x)
{
  this->Outputs_.set (x);
}

void Interface::
Outputs (const Outputs_optional& x)
{
  this->Outputs_ = x;
}

void Interface::
Outputs (::std::unique_ptr< Outputs_type > x)
{
  this->Outputs_.set (std::move (x));
}

const Interface::Instruments_optional& Interface::
Instruments () const
{
  return this->Instruments_;
}

Interface::Instruments_optional& Interface::
Instruments ()
{
  return this->Instruments_;
}

void Interface::
Instruments (const Instruments_type& x)
{
  this->Instruments_.set (x);
}

void Interface::
Instruments (const Instruments_optional& x)
{
  this->Instruments_ = x;
}

void Interface::
Instruments (::std::unique_ptr< Instruments_type > x)
{
  this->Instruments_.set (std::move (x));
}

const Interface::ControlSurfaces_optional& Interface::
ControlSurfaces () const
{
  return this->ControlSurfaces_;
}

Interface::ControlSurfaces_optional& Interface::
ControlSurfaces ()
{
  return this->ControlSurfaces_;
}

void Interface::
ControlSurfaces (const ControlSurfaces_type& x)
{
  this->ControlSurfaces_.set (x);
}

void Interface::
ControlSurfaces (const ControlSurfaces_optional& x)
{
  this->ControlSurfaces_ = x;
}

void Interface::
ControlSurfaces (::std::unique_ptr< ControlSurfaces_type > x)
{
  this->ControlSurfaces_.set (std::move (x));
}

const Interface::name_type& Interface::
name () const
{
  return this->name_.get ();
}

Interface::name_type& Interface::
name ()
{
  return this->name_.get ();
}

void Interface::
name (const name_type& x)
{
  this->name_.set (x);
}

void Interface::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// Midi
// 

const Midi::name_type& Midi::
name () const
{
  return this->name_.get ();
}

Midi::name_type& Midi::
name ()
{
  return this->name_.get ();
}

void Midi::
name (const name_type& x)
{
  this->name_.set (x);
}

void Midi::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const Midi::device_type& Midi::
device () const
{
  return this->device_.get ();
}

Midi::device_type& Midi::
device ()
{
  return this->device_.get ();
}

void Midi::
device (const device_type& x)
{
  this->device_.set (x);
}

void Midi::
device (::std::unique_ptr< device_type > x)
{
  this->device_.set (std::move (x));
}


// Osc
// 

const Osc::name_type& Osc::
name () const
{
  return this->name_.get ();
}

Osc::name_type& Osc::
name ()
{
  return this->name_.get ();
}

void Osc::
name (const name_type& x)
{
  this->name_.set (x);
}

void Osc::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const Osc::host_type& Osc::
host () const
{
  return this->host_.get ();
}

Osc::host_type& Osc::
host ()
{
  return this->host_.get ();
}

void Osc::
host (const host_type& x)
{
  this->host_.set (x);
}

void Osc::
host (::std::unique_ptr< host_type > x)
{
  this->host_.set (std::move (x));
}

const Osc::port_type& Osc::
port () const
{
  return this->port_.get ();
}

Osc::port_type& Osc::
port ()
{
  return this->port_.get ();
}

void Osc::
port (const port_type& x)
{
  this->port_.set (x);
}

void Osc::
port (::std::unique_ptr< port_type > x)
{
  this->port_.set (std::move (x));
}


// Voltage
// 

const Voltage::name_type& Voltage::
name () const
{
  return this->name_.get ();
}

Voltage::name_type& Voltage::
name ()
{
  return this->name_.get ();
}

void Voltage::
name (const name_type& x)
{
  this->name_.set (x);
}

void Voltage::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const Voltage::type_type& Voltage::
type () const
{
  return this->type_.get ();
}

Voltage::type_type& Voltage::
type ()
{
  return this->type_.get ();
}

void Voltage::
type (const type_type& x)
{
  this->type_.set (x);
}

void Voltage::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const Voltage::type_type& Voltage::
type_default_value ()
{
  return type_default_value_;
}

const Voltage::port_type& Voltage::
port () const
{
  return this->port_.get ();
}

Voltage::port_type& Voltage::
port ()
{
  return this->port_.get ();
}

void Voltage::
port (const port_type& x)
{
  this->port_.set (x);
}

void Voltage::
port (::std::unique_ptr< port_type > x)
{
  this->port_.set (std::move (x));
}


// Outputs
// 

const Outputs::Midi_sequence& Outputs::
Midi () const
{
  return this->Midi_;
}

Outputs::Midi_sequence& Outputs::
Midi ()
{
  return this->Midi_;
}

void Outputs::
Midi (const Midi_sequence& s)
{
  this->Midi_ = s;
}

const Outputs::Voltage_sequence& Outputs::
Voltage () const
{
  return this->Voltage_;
}

Outputs::Voltage_sequence& Outputs::
Voltage ()
{
  return this->Voltage_;
}

void Outputs::
Voltage (const Voltage_sequence& s)
{
  this->Voltage_ = s;
}

const Outputs::Osc_sequence& Outputs::
Osc () const
{
  return this->Osc_;
}

Outputs::Osc_sequence& Outputs::
Osc ()
{
  return this->Osc_;
}

void Outputs::
Osc (const Osc_sequence& s)
{
  this->Osc_ = s;
}


// Parameter
// 

const Parameter::Control_type& Parameter::
Control () const
{
  return this->Control_.get ();
}

Parameter::Control_type& Parameter::
Control ()
{
  return this->Control_.get ();
}

void Parameter::
Control (const Control_type& x)
{
  this->Control_.set (x);
}

void Parameter::
Control (::std::unique_ptr< Control_type > x)
{
  this->Control_.set (std::move (x));
}

const Parameter::name_type& Parameter::
name () const
{
  return this->name_.get ();
}

Parameter::name_type& Parameter::
name ()
{
  return this->name_.get ();
}

void Parameter::
name (const name_type& x)
{
  this->name_.set (x);
}

void Parameter::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const Parameter::type_type& Parameter::
type () const
{
  return this->type_.get ();
}

Parameter::type_type& Parameter::
type ()
{
  return this->type_.get ();
}

void Parameter::
type (const type_type& x)
{
  this->type_.set (x);
}

void Parameter::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const Parameter::type_type& Parameter::
type_default_value ()
{
  return type_default_value_;
}


// Voice
// 

const Voice::Control_type& Voice::
Control () const
{
  return this->Control_.get ();
}

Voice::Control_type& Voice::
Control ()
{
  return this->Control_.get ();
}

void Voice::
Control (const Control_type& x)
{
  this->Control_.set (x);
}

void Voice::
Control (::std::unique_ptr< Control_type > x)
{
  this->Control_.set (std::move (x));
}

const Voice::name_type& Voice::
name () const
{
  return this->name_.get ();
}

Voice::name_type& Voice::
name ()
{
  return this->name_.get ();
}

void Voice::
name (const name_type& x)
{
  this->name_.set (x);
}

void Voice::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// Instrument
// 

const Instrument::Parameter_sequence& Instrument::
Parameter () const
{
  return this->Parameter_;
}

Instrument::Parameter_sequence& Instrument::
Parameter ()
{
  return this->Parameter_;
}

void Instrument::
Parameter (const Parameter_sequence& s)
{
  this->Parameter_ = s;
}

const Instrument::Voice_sequence& Instrument::
Voice () const
{
  return this->Voice_;
}

Instrument::Voice_sequence& Instrument::
Voice ()
{
  return this->Voice_;
}

void Instrument::
Voice (const Voice_sequence& s)
{
  this->Voice_ = s;
}

const Instrument::name_type& Instrument::
name () const
{
  return this->name_.get ();
}

Instrument::name_type& Instrument::
name ()
{
  return this->name_.get ();
}

void Instrument::
name (const name_type& x)
{
  this->name_.set (x);
}

void Instrument::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// Instruments
// 

const Instruments::Instrument_sequence& Instruments::
Instrument () const
{
  return this->Instrument_;
}

Instruments::Instrument_sequence& Instruments::
Instrument ()
{
  return this->Instrument_;
}

void Instruments::
Instrument (const Instrument_sequence& s)
{
  this->Instrument_ = s;
}


// Layout
// 

const Layout::name_type& Layout::
name () const
{
  return this->name_.get ();
}

Layout::name_type& Layout::
name ()
{
  return this->name_.get ();
}

void Layout::
name (const name_type& x)
{
  this->name_.set (x);
}

void Layout::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// ControlSurfaces
// 

const ControlSurfaces::Midi_sequence& ControlSurfaces::
Midi () const
{
  return this->Midi_;
}

ControlSurfaces::Midi_sequence& ControlSurfaces::
Midi ()
{
  return this->Midi_;
}

void ControlSurfaces::
Midi (const Midi_sequence& s)
{
  this->Midi_ = s;
}

const ControlSurfaces::Voltage_sequence& ControlSurfaces::
Voltage () const
{
  return this->Voltage_;
}

ControlSurfaces::Voltage_sequence& ControlSurfaces::
Voltage ()
{
  return this->Voltage_;
}

void ControlSurfaces::
Voltage (const Voltage_sequence& s)
{
  this->Voltage_ = s;
}

const ControlSurfaces::Grid_sequence& ControlSurfaces::
Grid () const
{
  return this->Grid_;
}

ControlSurfaces::Grid_sequence& ControlSurfaces::
Grid ()
{
  return this->Grid_;
}

void ControlSurfaces::
Grid (const Grid_sequence& s)
{
  this->Grid_ = s;
}


// type
// 

type::
type (value v)
: ::xml_schema::string (_xsd_type_literals_[v])
{
}

type::
type (const char* v)
: ::xml_schema::string (v)
{
}

type::
type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

type::
type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

type::
type (const type& v,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

type& type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_type_literals_[v]);

  return *this;
}


// Control
// 

const Control::Midi_type& Control::
Midi () const
{
  return this->Midi_.get ();
}

Control::Midi_type& Control::
Midi ()
{
  return this->Midi_.get ();
}

void Control::
Midi (const Midi_type& x)
{
  this->Midi_.set (x);
}

void Control::
Midi (::std::unique_ptr< Midi_type > x)
{
  this->Midi_.set (std::move (x));
}

const Control::Voltage_type& Control::
Voltage () const
{
  return this->Voltage_.get ();
}

Control::Voltage_type& Control::
Voltage ()
{
  return this->Voltage_.get ();
}

void Control::
Voltage (const Voltage_type& x)
{
  this->Voltage_.set (x);
}

void Control::
Voltage (::std::unique_ptr< Voltage_type > x)
{
  this->Voltage_.set (std::move (x));
}

const Control::Osc_type& Control::
Osc () const
{
  return this->Osc_.get ();
}

Control::Osc_type& Control::
Osc ()
{
  return this->Osc_.get ();
}

void Control::
Osc (const Osc_type& x)
{
  this->Osc_.set (x);
}

void Control::
Osc (::std::unique_ptr< Osc_type > x)
{
  this->Osc_.set (std::move (x));
}


// type1
// 

type1::
type1 (value v)
: ::xml_schema::string (_xsd_type1_literals_[v])
{
}

type1::
type1 (const char* v)
: ::xml_schema::string (v)
{
}

type1::
type1 (const ::std::string& v)
: ::xml_schema::string (v)
{
}

type1::
type1 (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

type1::
type1 (const type1& v,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

type1& type1::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_type1_literals_[v]);

  return *this;
}


// Control1
// 

const Control1::Midi_type& Control1::
Midi () const
{
  return this->Midi_.get ();
}

Control1::Midi_type& Control1::
Midi ()
{
  return this->Midi_.get ();
}

void Control1::
Midi (const Midi_type& x)
{
  this->Midi_.set (x);
}

void Control1::
Midi (::std::unique_ptr< Midi_type > x)
{
  this->Midi_.set (std::move (x));
}

const Control1::Voltage_type& Control1::
Voltage () const
{
  return this->Voltage_.get ();
}

Control1::Voltage_type& Control1::
Voltage ()
{
  return this->Voltage_.get ();
}

void Control1::
Voltage (const Voltage_type& x)
{
  this->Voltage_.set (x);
}

void Control1::
Voltage (::std::unique_ptr< Voltage_type > x)
{
  this->Voltage_.set (std::move (x));
}


// Grid
// 

const Grid::Dimensions_type& Grid::
Dimensions () const
{
  return this->Dimensions_.get ();
}

Grid::Dimensions_type& Grid::
Dimensions ()
{
  return this->Dimensions_.get ();
}

void Grid::
Dimensions (const Dimensions_type& x)
{
  this->Dimensions_.set (x);
}

void Grid::
Dimensions (::std::unique_ptr< Dimensions_type > x)
{
  this->Dimensions_.set (std::move (x));
}

const Grid::Layouts_type& Grid::
Layouts () const
{
  return this->Layouts_.get ();
}

Grid::Layouts_type& Grid::
Layouts ()
{
  return this->Layouts_.get ();
}

void Grid::
Layouts (const Layouts_type& x)
{
  this->Layouts_.set (x);
}

void Grid::
Layouts (::std::unique_ptr< Layouts_type > x)
{
  this->Layouts_.set (std::move (x));
}

const Grid::name_type& Grid::
name () const
{
  return this->name_.get ();
}

Grid::name_type& Grid::
name ()
{
  return this->name_.get ();
}

void Grid::
name (const name_type& x)
{
  this->name_.set (x);
}

void Grid::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const Grid::type_type& Grid::
type () const
{
  return this->type_.get ();
}

Grid::type_type& Grid::
type ()
{
  return this->type_.get ();
}

void Grid::
type (const type_type& x)
{
  this->type_.set (x);
}

void Grid::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const Grid::device_type& Grid::
device () const
{
  return this->device_.get ();
}

Grid::device_type& Grid::
device ()
{
  return this->device_.get ();
}

void Grid::
device (const device_type& x)
{
  this->device_.set (x);
}

void Grid::
device (::std::unique_ptr< device_type > x)
{
  this->device_.set (std::move (x));
}


// Midi1
// 

const Midi1::Message_sequence& Midi1::
Message () const
{
  return this->Message_;
}

Midi1::Message_sequence& Midi1::
Message ()
{
  return this->Message_;
}

void Midi1::
Message (const Message_sequence& s)
{
  this->Message_ = s;
}

const Midi1::output_type& Midi1::
output () const
{
  return this->output_.get ();
}

Midi1::output_type& Midi1::
output ()
{
  return this->output_.get ();
}

void Midi1::
output (const output_type& x)
{
  this->output_.set (x);
}

void Midi1::
output (::std::unique_ptr< output_type > x)
{
  this->output_.set (std::move (x));
}

const Midi1::channel_type& Midi1::
channel () const
{
  return this->channel_.get ();
}

Midi1::channel_type& Midi1::
channel ()
{
  return this->channel_.get ();
}

void Midi1::
channel (const channel_type& x)
{
  this->channel_.set (x);
}

const Midi1::arg_type& Midi1::
arg () const
{
  return this->arg_.get ();
}

Midi1::arg_type& Midi1::
arg ()
{
  return this->arg_.get ();
}

void Midi1::
arg (const arg_type& x)
{
  this->arg_.set (x);
}

void Midi1::
arg (::std::unique_ptr< arg_type > x)
{
  this->arg_.set (std::move (x));
}


// Midi2
// 

const Midi2::note_type& Midi2::
note () const
{
  return this->note_.get ();
}

Midi2::note_type& Midi2::
note ()
{
  return this->note_.get ();
}

void Midi2::
note (const note_type& x)
{
  this->note_.set (x);
}

void Midi2::
note (::std::unique_ptr< note_type > x)
{
  this->note_.set (std::move (x));
}

const Midi2::output_type& Midi2::
output () const
{
  return this->output_.get ();
}

Midi2::output_type& Midi2::
output ()
{
  return this->output_.get ();
}

void Midi2::
output (const output_type& x)
{
  this->output_.set (x);
}

void Midi2::
output (::std::unique_ptr< output_type > x)
{
  this->output_.set (std::move (x));
}

const Midi2::channel_type& Midi2::
channel () const
{
  return this->channel_.get ();
}

Midi2::channel_type& Midi2::
channel ()
{
  return this->channel_.get ();
}

void Midi2::
channel (const channel_type& x)
{
  this->channel_.set (x);
}

void Midi2::
channel (::std::unique_ptr< channel_type > x)
{
  this->channel_.set (std::move (x));
}


// Dimensions
// 

const Dimensions::width_type& Dimensions::
width () const
{
  return this->width_.get ();
}

Dimensions::width_type& Dimensions::
width ()
{
  return this->width_.get ();
}

void Dimensions::
width (const width_type& x)
{
  this->width_.set (x);
}

const Dimensions::height_type& Dimensions::
height () const
{
  return this->height_.get ();
}

Dimensions::height_type& Dimensions::
height ()
{
  return this->height_.get ();
}

void Dimensions::
height (const height_type& x)
{
  this->height_.set (x);
}


// Layouts
// 

const Layouts::Layout_sequence& Layouts::
Layout () const
{
  return this->Layout_;
}

Layouts::Layout_sequence& Layouts::
Layout ()
{
  return this->Layout_;
}

void Layouts::
Layout (const Layout_sequence& s)
{
  this->Layout_ = s;
}


// type2
// 

type2::
type2 (value v)
: ::xml_schema::string (_xsd_type2_literals_[v])
{
}

type2::
type2 (const char* v)
: ::xml_schema::string (v)
{
}

type2::
type2 (const ::std::string& v)
: ::xml_schema::string (v)
{
}

type2::
type2 (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

type2::
type2 (const type2& v,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

type2& type2::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_type2_literals_[v]);

  return *this;
}


// Message
// 

const Message::Byte_sequence& Message::
Byte () const
{
  return this->Byte_;
}

Message::Byte_sequence& Message::
Byte ()
{
  return this->Byte_;
}

void Message::
Byte (const Byte_sequence& s)
{
  this->Byte_ = s;
}


// note
// 


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// name
//

name::
name ()
: ::xml_schema::string ()
{
}

name::
name (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

name::
name (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

name::
name (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

name::
name (const name& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

name::
name (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

name::
name (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

name::
name (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

name* name::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class name (*this, f, c);
}

name::
~name ()
{
}

// Interface
//

Interface::
Interface (const name_type& name)
: ::xml_schema::type (),
  Outputs_ (this),
  Instruments_ (this),
  ControlSurfaces_ (this),
  name_ (name, this)
{
}

Interface::
Interface (const Interface& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Outputs_ (x.Outputs_, f, this),
  Instruments_ (x.Instruments_, f, this),
  ControlSurfaces_ (x.ControlSurfaces_, f, this),
  name_ (x.name_, f, this)
{
}

Interface::
Interface (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Outputs_ (this),
  Instruments_ (this),
  ControlSurfaces_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Interface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Outputs
    //
    if (n.name () == "Outputs" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Outputs_type > r (
        Outputs_traits::create (i, f, this));

      if (!this->Outputs_)
      {
        this->Outputs_.set (::std::move (r));
        continue;
      }
    }

    // Instruments
    //
    if (n.name () == "Instruments" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Instruments_type > r (
        Instruments_traits::create (i, f, this));

      if (!this->Instruments_)
      {
        this->Instruments_.set (::std::move (r));
        continue;
      }
    }

    // ControlSurfaces
    //
    if (n.name () == "ControlSurfaces" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ControlSurfaces_type > r (
        ControlSurfaces_traits::create (i, f, this));

      if (!this->ControlSurfaces_)
      {
        this->ControlSurfaces_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

Interface* Interface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Interface (*this, f, c);
}

Interface& Interface::
operator= (const Interface& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Outputs_ = x.Outputs_;
    this->Instruments_ = x.Instruments_;
    this->ControlSurfaces_ = x.ControlSurfaces_;
    this->name_ = x.name_;
  }

  return *this;
}

Interface::
~Interface ()
{
}

// Midi
//

Midi::
Midi (const name_type& name,
      const device_type& device)
: ::xml_schema::type (),
  name_ (name, this),
  device_ (device, this)
{
}

Midi::
Midi (const Midi& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  device_ (x.device_, f, this)
{
}

Midi::
Midi (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  device_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Midi::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "device" && n.namespace_ ().empty ())
    {
      this->device_.set (device_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!device_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "device",
      "");
  }
}

Midi* Midi::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Midi (*this, f, c);
}

Midi& Midi::
operator= (const Midi& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->device_ = x.device_;
  }

  return *this;
}

Midi::
~Midi ()
{
}

// Osc
//

Osc::
Osc (const name_type& name,
     const host_type& host,
     const port_type& port)
: ::xml_schema::type (),
  name_ (name, this),
  host_ (host, this),
  port_ (port, this)
{
}

Osc::
Osc (const Osc& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  host_ (x.host_, f, this),
  port_ (x.port_, f, this)
{
}

Osc::
Osc (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  host_ (this),
  port_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Osc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "host" && n.namespace_ ().empty ())
    {
      this->host_.set (host_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "port" && n.namespace_ ().empty ())
    {
      this->port_.set (port_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!host_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "host",
      "");
  }

  if (!port_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "port",
      "");
  }
}

Osc* Osc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Osc (*this, f, c);
}

Osc& Osc::
operator= (const Osc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->host_ = x.host_;
    this->port_ = x.port_;
  }

  return *this;
}

Osc::
~Osc ()
{
}

// Voltage
//

const Voltage::type_type Voltage::type_default_value_ (
  "control");

Voltage::
Voltage (const name_type& name,
         const port_type& port)
: ::xml_schema::type (),
  name_ (name, this),
  type_ (type_default_value (), this),
  port_ (port, this)
{
}

Voltage::
Voltage (const Voltage& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  type_ (x.type_, f, this),
  port_ (x.port_, f, this)
{
}

Voltage::
Voltage (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  type_ (this),
  port_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Voltage::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "port" && n.namespace_ ().empty ())
    {
      this->port_.set (port_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!type_.present ())
  {
    this->type_.set (type_default_value ());
  }

  if (!port_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "port",
      "");
  }
}

Voltage* Voltage::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Voltage (*this, f, c);
}

Voltage& Voltage::
operator= (const Voltage& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->type_ = x.type_;
    this->port_ = x.port_;
  }

  return *this;
}

Voltage::
~Voltage ()
{
}

// Outputs
//

Outputs::
Outputs ()
: ::xml_schema::type (),
  Midi_ (this),
  Voltage_ (this),
  Osc_ (this)
{
}

Outputs::
Outputs (const Outputs& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Midi_ (x.Midi_, f, this),
  Voltage_ (x.Voltage_, f, this),
  Osc_ (x.Osc_, f, this)
{
}

Outputs::
Outputs (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Midi_ (this),
  Voltage_ (this),
  Osc_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Outputs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Midi
    //
    if (n.name () == "Midi" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Midi_type > r (
        Midi_traits::create (i, f, this));

      this->Midi_.push_back (::std::move (r));
      continue;
    }

    // Voltage
    //
    if (n.name () == "Voltage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Voltage_type > r (
        Voltage_traits::create (i, f, this));

      this->Voltage_.push_back (::std::move (r));
      continue;
    }

    // Osc
    //
    if (n.name () == "Osc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Osc_type > r (
        Osc_traits::create (i, f, this));

      this->Osc_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Outputs* Outputs::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Outputs (*this, f, c);
}

Outputs& Outputs::
operator= (const Outputs& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Midi_ = x.Midi_;
    this->Voltage_ = x.Voltage_;
    this->Osc_ = x.Osc_;
  }

  return *this;
}

Outputs::
~Outputs ()
{
}

// Parameter
//

const Parameter::type_type Parameter::type_default_value_ (
  "continuous");

Parameter::
Parameter (const Control_type& Control,
           const name_type& name)
: ::xml_schema::type (),
  Control_ (Control, this),
  name_ (name, this),
  type_ (type_default_value (), this)
{
}

Parameter::
Parameter (::std::unique_ptr< Control_type > Control,
           const name_type& name)
: ::xml_schema::type (),
  Control_ (std::move (Control), this),
  name_ (name, this),
  type_ (type_default_value (), this)
{
}

Parameter::
Parameter (const Parameter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Control_ (x.Control_, f, this),
  name_ (x.name_, f, this),
  type_ (x.type_, f, this)
{
}

Parameter::
Parameter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Control_ (this),
  name_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Parameter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Control
    //
    if (n.name () == "Control" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Control_type > r (
        Control_traits::create (i, f, this));

      if (!Control_.present ())
      {
        this->Control_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Control",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!type_.present ())
  {
    this->type_.set (type_default_value ());
  }
}

Parameter* Parameter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Parameter (*this, f, c);
}

Parameter& Parameter::
operator= (const Parameter& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Control_ = x.Control_;
    this->name_ = x.name_;
    this->type_ = x.type_;
  }

  return *this;
}

Parameter::
~Parameter ()
{
}

// Voice
//

Voice::
Voice (const Control_type& Control,
       const name_type& name)
: ::xml_schema::type (),
  Control_ (Control, this),
  name_ (name, this)
{
}

Voice::
Voice (::std::unique_ptr< Control_type > Control,
       const name_type& name)
: ::xml_schema::type (),
  Control_ (std::move (Control), this),
  name_ (name, this)
{
}

Voice::
Voice (const Voice& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Control_ (x.Control_, f, this),
  name_ (x.name_, f, this)
{
}

Voice::
Voice (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Control_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Voice::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Control
    //
    if (n.name () == "Control" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Control_type > r (
        Control_traits::create (i, f, this));

      if (!Control_.present ())
      {
        this->Control_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Control",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

Voice* Voice::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Voice (*this, f, c);
}

Voice& Voice::
operator= (const Voice& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Control_ = x.Control_;
    this->name_ = x.name_;
  }

  return *this;
}

Voice::
~Voice ()
{
}

// Instrument
//

Instrument::
Instrument (const name_type& name)
: ::xml_schema::type (),
  Parameter_ (this),
  Voice_ (this),
  name_ (name, this)
{
}

Instrument::
Instrument (const Instrument& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Parameter_ (x.Parameter_, f, this),
  Voice_ (x.Voice_, f, this),
  name_ (x.name_, f, this)
{
}

Instrument::
Instrument (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Parameter_ (this),
  Voice_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Instrument::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Parameter
    //
    if (n.name () == "Parameter" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Parameter_type > r (
        Parameter_traits::create (i, f, this));

      this->Parameter_.push_back (::std::move (r));
      continue;
    }

    // Voice
    //
    if (n.name () == "Voice" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Voice_type > r (
        Voice_traits::create (i, f, this));

      this->Voice_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

Instrument* Instrument::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Instrument (*this, f, c);
}

Instrument& Instrument::
operator= (const Instrument& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Parameter_ = x.Parameter_;
    this->Voice_ = x.Voice_;
    this->name_ = x.name_;
  }

  return *this;
}

Instrument::
~Instrument ()
{
}

// Instruments
//

Instruments::
Instruments ()
: ::xml_schema::type (),
  Instrument_ (this)
{
}

Instruments::
Instruments (const Instruments& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Instrument_ (x.Instrument_, f, this)
{
}

Instruments::
Instruments (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Instrument_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Instruments::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Instrument
    //
    if (n.name () == "Instrument" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Instrument_type > r (
        Instrument_traits::create (i, f, this));

      this->Instrument_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Instruments* Instruments::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Instruments (*this, f, c);
}

Instruments& Instruments::
operator= (const Instruments& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Instrument_ = x.Instrument_;
  }

  return *this;
}

Instruments::
~Instruments ()
{
}

// Layout
//

Layout::
Layout (const name_type& name)
: ::xml_schema::type (),
  name_ (name, this)
{
}

Layout::
Layout (const Layout& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this)
{
}

Layout::
Layout (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Layout::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

Layout* Layout::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Layout (*this, f, c);
}

Layout& Layout::
operator= (const Layout& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
  }

  return *this;
}

Layout::
~Layout ()
{
}

// ControlSurfaces
//

ControlSurfaces::
ControlSurfaces ()
: ::xml_schema::type (),
  Midi_ (this),
  Voltage_ (this),
  Grid_ (this)
{
}

ControlSurfaces::
ControlSurfaces (const ControlSurfaces& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Midi_ (x.Midi_, f, this),
  Voltage_ (x.Voltage_, f, this),
  Grid_ (x.Grid_, f, this)
{
}

ControlSurfaces::
ControlSurfaces (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Midi_ (this),
  Voltage_ (this),
  Grid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ControlSurfaces::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Midi
    //
    if (n.name () == "Midi" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Midi_type > r (
        Midi_traits::create (i, f, this));

      this->Midi_.push_back (::std::move (r));
      continue;
    }

    // Voltage
    //
    if (n.name () == "Voltage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Voltage_type > r (
        Voltage_traits::create (i, f, this));

      this->Voltage_.push_back (::std::move (r));
      continue;
    }

    // Grid
    //
    if (n.name () == "Grid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Grid_type > r (
        Grid_traits::create (i, f, this));

      this->Grid_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

ControlSurfaces* ControlSurfaces::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ControlSurfaces (*this, f, c);
}

ControlSurfaces& ControlSurfaces::
operator= (const ControlSurfaces& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Midi_ = x.Midi_;
    this->Voltage_ = x.Voltage_;
    this->Grid_ = x.Grid_;
  }

  return *this;
}

ControlSurfaces::
~ControlSurfaces ()
{
}

// type
//

type::
type (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_type_convert ();
}

type::
type (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_type_convert ();
}

type::
type (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_type_convert ();
}

type* type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type (*this, f, c);
}

type::value type::
_xsd_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_type_indexes_,
                    _xsd_type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_type_indexes_ + 3 || _xsd_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const type::
_xsd_type_literals_[3] =
{
  "control",
  "gate",
  "trigger"
};

const type::value type::
_xsd_type_indexes_[3] =
{
  ::type::control,
  ::type::gate,
  ::type::trigger
};

// Control
//

Control::
Control (const Midi_type& Midi,
         const Voltage_type& Voltage,
         const Osc_type& Osc)
: ::xml_schema::type (),
  Midi_ (Midi, this),
  Voltage_ (Voltage, this),
  Osc_ (Osc, this)
{
}

Control::
Control (::std::unique_ptr< Midi_type > Midi,
         const Voltage_type& Voltage,
         const Osc_type& Osc)
: ::xml_schema::type (),
  Midi_ (std::move (Midi), this),
  Voltage_ (Voltage, this),
  Osc_ (Osc, this)
{
}

Control::
Control (const Control& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Midi_ (x.Midi_, f, this),
  Voltage_ (x.Voltage_, f, this),
  Osc_ (x.Osc_, f, this)
{
}

Control::
Control (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Midi_ (this),
  Voltage_ (this),
  Osc_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Control::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Midi
    //
    if (n.name () == "Midi" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Midi_type > r (
        Midi_traits::create (i, f, this));

      if (!Midi_.present ())
      {
        this->Midi_.set (::std::move (r));
        continue;
      }
    }

    // Voltage
    //
    if (n.name () == "Voltage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Voltage_type > r (
        Voltage_traits::create (i, f, this));

      if (!Voltage_.present ())
      {
        this->Voltage_.set (::std::move (r));
        continue;
      }
    }

    // Osc
    //
    if (n.name () == "Osc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Osc_type > r (
        Osc_traits::create (i, f, this));

      if (!Osc_.present ())
      {
        this->Osc_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Midi_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Midi",
      "");
  }

  if (!Voltage_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Voltage",
      "");
  }

  if (!Osc_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Osc",
      "");
  }
}

Control* Control::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Control (*this, f, c);
}

Control& Control::
operator= (const Control& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Midi_ = x.Midi_;
    this->Voltage_ = x.Voltage_;
    this->Osc_ = x.Osc_;
  }

  return *this;
}

Control::
~Control ()
{
}

// type1
//

type1::
type1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_type1_convert ();
}

type1::
type1 (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_type1_convert ();
}

type1::
type1 (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_type1_convert ();
}

type1* type1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type1 (*this, f, c);
}

type1::value type1::
_xsd_type1_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type1_literals_);
  const value* i (::std::lower_bound (
                    _xsd_type1_indexes_,
                    _xsd_type1_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_type1_indexes_ + 2 || _xsd_type1_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const type1::
_xsd_type1_literals_[2] =
{
  "continuous",
  "discrete"
};

const type1::value type1::
_xsd_type1_indexes_[2] =
{
  ::type1::continuous,
  ::type1::discrete
};

// Control1
//

Control1::
Control1 (const Midi_type& Midi,
          const Voltage_type& Voltage)
: ::xml_schema::type (),
  Midi_ (Midi, this),
  Voltage_ (Voltage, this)
{
}

Control1::
Control1 (::std::unique_ptr< Midi_type > Midi,
          const Voltage_type& Voltage)
: ::xml_schema::type (),
  Midi_ (std::move (Midi), this),
  Voltage_ (Voltage, this)
{
}

Control1::
Control1 (const Control1& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Midi_ (x.Midi_, f, this),
  Voltage_ (x.Voltage_, f, this)
{
}

Control1::
Control1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Midi_ (this),
  Voltage_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Control1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Midi
    //
    if (n.name () == "Midi" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Midi_type > r (
        Midi_traits::create (i, f, this));

      if (!Midi_.present ())
      {
        this->Midi_.set (::std::move (r));
        continue;
      }
    }

    // Voltage
    //
    if (n.name () == "Voltage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Voltage_type > r (
        Voltage_traits::create (i, f, this));

      if (!Voltage_.present ())
      {
        this->Voltage_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Midi_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Midi",
      "");
  }

  if (!Voltage_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Voltage",
      "");
  }
}

Control1* Control1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Control1 (*this, f, c);
}

Control1& Control1::
operator= (const Control1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Midi_ = x.Midi_;
    this->Voltage_ = x.Voltage_;
  }

  return *this;
}

Control1::
~Control1 ()
{
}

// Grid
//

Grid::
Grid (const Dimensions_type& Dimensions,
      const Layouts_type& Layouts,
      const name_type& name,
      const type_type& type,
      const device_type& device)
: ::xml_schema::type (),
  Dimensions_ (Dimensions, this),
  Layouts_ (Layouts, this),
  name_ (name, this),
  type_ (type, this),
  device_ (device, this)
{
}

Grid::
Grid (::std::unique_ptr< Dimensions_type > Dimensions,
      ::std::unique_ptr< Layouts_type > Layouts,
      const name_type& name,
      const type_type& type,
      const device_type& device)
: ::xml_schema::type (),
  Dimensions_ (std::move (Dimensions), this),
  Layouts_ (std::move (Layouts), this),
  name_ (name, this),
  type_ (type, this),
  device_ (device, this)
{
}

Grid::
Grid (const Grid& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Dimensions_ (x.Dimensions_, f, this),
  Layouts_ (x.Layouts_, f, this),
  name_ (x.name_, f, this),
  type_ (x.type_, f, this),
  device_ (x.device_, f, this)
{
}

Grid::
Grid (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Dimensions_ (this),
  Layouts_ (this),
  name_ (this),
  type_ (this),
  device_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Grid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Dimensions
    //
    if (n.name () == "Dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Dimensions_type > r (
        Dimensions_traits::create (i, f, this));

      if (!Dimensions_.present ())
      {
        this->Dimensions_.set (::std::move (r));
        continue;
      }
    }

    // Layouts
    //
    if (n.name () == "Layouts" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Layouts_type > r (
        Layouts_traits::create (i, f, this));

      if (!Layouts_.present ())
      {
        this->Layouts_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Dimensions",
      "");
  }

  if (!Layouts_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Layouts",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "device" && n.namespace_ ().empty ())
    {
      this->device_.set (device_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!device_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "device",
      "");
  }
}

Grid* Grid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Grid (*this, f, c);
}

Grid& Grid::
operator= (const Grid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Dimensions_ = x.Dimensions_;
    this->Layouts_ = x.Layouts_;
    this->name_ = x.name_;
    this->type_ = x.type_;
    this->device_ = x.device_;
  }

  return *this;
}

Grid::
~Grid ()
{
}

// Midi1
//

Midi1::
Midi1 (const output_type& output,
       const channel_type& channel,
       const arg_type& arg)
: ::xml_schema::type (),
  Message_ (this),
  output_ (output, this),
  channel_ (channel, this),
  arg_ (arg, this)
{
}

Midi1::
Midi1 (const Midi1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Message_ (x.Message_, f, this),
  output_ (x.output_, f, this),
  channel_ (x.channel_, f, this),
  arg_ (x.arg_, f, this)
{
}

Midi1::
Midi1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Message_ (this),
  output_ (this),
  channel_ (this),
  arg_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Midi1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Message
    //
    if (n.name () == "Message" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Message_type > r (
        Message_traits::create (i, f, this));

      this->Message_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      this->output_.set (output_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "channel" && n.namespace_ ().empty ())
    {
      this->channel_.set (channel_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "arg" && n.namespace_ ().empty ())
    {
      this->arg_.set (arg_traits::create (i, f, this));
      continue;
    }
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output",
      "");
  }

  if (!channel_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "channel",
      "");
  }

  if (!arg_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "arg",
      "");
  }
}

Midi1* Midi1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Midi1 (*this, f, c);
}

Midi1& Midi1::
operator= (const Midi1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Message_ = x.Message_;
    this->output_ = x.output_;
    this->channel_ = x.channel_;
    this->arg_ = x.arg_;
  }

  return *this;
}

Midi1::
~Midi1 ()
{
}

// Midi2
//

Midi2::
Midi2 (const note_type& note,
       const output_type& output,
       const channel_type& channel)
: ::xml_schema::type (),
  note_ (note, this),
  output_ (output, this),
  channel_ (channel, this)
{
}

Midi2::
Midi2 (const Midi2& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  note_ (x.note_, f, this),
  output_ (x.output_, f, this),
  channel_ (x.channel_, f, this)
{
}

Midi2::
Midi2 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  note_ (this),
  output_ (this),
  channel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Midi2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "note" && n.namespace_ ().empty ())
    {
      this->note_.set (note_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      this->output_.set (output_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "channel" && n.namespace_ ().empty ())
    {
      this->channel_.set (channel_traits::create (i, f, this));
      continue;
    }
  }

  if (!note_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "note",
      "");
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output",
      "");
  }

  if (!channel_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "channel",
      "");
  }
}

Midi2* Midi2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Midi2 (*this, f, c);
}

Midi2& Midi2::
operator= (const Midi2& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->note_ = x.note_;
    this->output_ = x.output_;
    this->channel_ = x.channel_;
  }

  return *this;
}

Midi2::
~Midi2 ()
{
}

// Dimensions
//

Dimensions::
Dimensions (const width_type& width,
            const height_type& height)
: ::xml_schema::type (),
  width_ (width, this),
  height_ (height, this)
{
}

Dimensions::
Dimensions (const Dimensions& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  width_ (x.width_, f, this),
  height_ (x.height_, f, this)
{
}

Dimensions::
Dimensions (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  width_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Dimensions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }
}

Dimensions* Dimensions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Dimensions (*this, f, c);
}

Dimensions& Dimensions::
operator= (const Dimensions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->width_ = x.width_;
    this->height_ = x.height_;
  }

  return *this;
}

Dimensions::
~Dimensions ()
{
}

// Layouts
//

Layouts::
Layouts ()
: ::xml_schema::type (),
  Layout_ (this)
{
}

Layouts::
Layouts (const Layouts& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Layout_ (x.Layout_, f, this)
{
}

Layouts::
Layouts (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Layout_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Layouts::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Layout
    //
    if (n.name () == "Layout" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Layout_type > r (
        Layout_traits::create (i, f, this));

      this->Layout_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Layouts* Layouts::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Layouts (*this, f, c);
}

Layouts& Layouts::
operator= (const Layouts& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Layout_ = x.Layout_;
  }

  return *this;
}

Layouts::
~Layouts ()
{
}

// type2
//

type2::
type2 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_type2_convert ();
}

type2::
type2 (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_type2_convert ();
}

type2::
type2 (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_type2_convert ();
}

type2* type2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type2 (*this, f, c);
}

type2::value type2::
_xsd_type2_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type2_literals_);
  const value* i (::std::lower_bound (
                    _xsd_type2_indexes_,
                    _xsd_type2_indexes_ + 1,
                    *this,
                    c));

  if (i == _xsd_type2_indexes_ + 1 || _xsd_type2_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const type2::
_xsd_type2_literals_[1] =
{
  "monome"
};

const type2::value type2::
_xsd_type2_indexes_[1] =
{
  ::type2::monome
};

// Message
//

Message::
Message ()
: ::xml_schema::type (),
  Byte_ (this)
{
}

Message::
Message (const Message& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Byte_ (x.Byte_, f, this)
{
}

Message::
Message (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Byte_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Message::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Byte
    //
    if (n.name () == "Byte" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Byte_type > r (
        Byte_traits::create (i, f, this));

      this->Byte_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

Message* Message::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Message (*this, f, c);
}

Message& Message::
operator= (const Message& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Byte_ = x.Byte_;
  }

  return *this;
}

Message::
~Message ()
{
}

// note
//

note::
note ()
: ::xml_schema::string ()
{
}

note::
note (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

note::
note (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

note::
note (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

note::
note (const note& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

note::
note (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

note::
note (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

note::
note (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

note* note::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class note (*this, f, c);
}

note::
~note ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::Interface >
Interface_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Interface > (
    ::Interface_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Interface >
Interface_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Interface > (
    ::Interface_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Interface >
Interface_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Interface > (
    ::Interface_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Interface >
Interface_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Interface_ (isrc, f, p);
}

::std::unique_ptr< ::Interface >
Interface_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Interface_ (isrc, h, f, p);
}

::std::unique_ptr< ::Interface >
Interface_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Interface_ (isrc, h, f, p);
}

::std::unique_ptr< ::Interface >
Interface_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Interface_ (isrc, f, p);
}

::std::unique_ptr< ::Interface >
Interface_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Interface_ (isrc, h, f, p);
}

::std::unique_ptr< ::Interface >
Interface_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Interface_ (isrc, h, f, p);
}

::std::unique_ptr< ::Interface >
Interface_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Interface > (
    ::Interface_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Interface >
Interface_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Interface > (
    ::Interface_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Interface >
Interface_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Interface > (
    ::Interface_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Interface >
Interface_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Interface > (
      ::Interface_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Interface" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Interface > r (
      ::xsd::cxx::tree::traits< ::Interface, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Interface",
    "");
}

::std::unique_ptr< ::Interface >
Interface_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Interface" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Interface > r (
      ::xsd::cxx::tree::traits< ::Interface, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Interface",
    "");
}

::std::unique_ptr< ::Midi >
Midi_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Midi > (
    ::Midi_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Midi >
Midi_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Midi > (
    ::Midi_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Midi >
Midi_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Midi > (
    ::Midi_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Midi >
Midi_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Midi_ (isrc, f, p);
}

::std::unique_ptr< ::Midi >
Midi_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Midi_ (isrc, h, f, p);
}

::std::unique_ptr< ::Midi >
Midi_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Midi_ (isrc, h, f, p);
}

::std::unique_ptr< ::Midi >
Midi_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Midi_ (isrc, f, p);
}

::std::unique_ptr< ::Midi >
Midi_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Midi_ (isrc, h, f, p);
}

::std::unique_ptr< ::Midi >
Midi_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Midi_ (isrc, h, f, p);
}

::std::unique_ptr< ::Midi >
Midi_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Midi > (
    ::Midi_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Midi >
Midi_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Midi > (
    ::Midi_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Midi >
Midi_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Midi > (
    ::Midi_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Midi >
Midi_ (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Midi > (
      ::Midi_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Midi" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Midi > r (
      ::xsd::cxx::tree::traits< ::Midi, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Midi",
    "");
}

::std::unique_ptr< ::Midi >
Midi_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Midi" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Midi > r (
      ::xsd::cxx::tree::traits< ::Midi, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Midi",
    "");
}

::std::unique_ptr< ::Osc >
Osc_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Osc > (
    ::Osc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Osc >
Osc_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Osc > (
    ::Osc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Osc >
Osc_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Osc > (
    ::Osc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Osc >
Osc_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Osc_ (isrc, f, p);
}

::std::unique_ptr< ::Osc >
Osc_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Osc_ (isrc, h, f, p);
}

::std::unique_ptr< ::Osc >
Osc_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Osc_ (isrc, h, f, p);
}

::std::unique_ptr< ::Osc >
Osc_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Osc_ (isrc, f, p);
}

::std::unique_ptr< ::Osc >
Osc_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Osc_ (isrc, h, f, p);
}

::std::unique_ptr< ::Osc >
Osc_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Osc_ (isrc, h, f, p);
}

::std::unique_ptr< ::Osc >
Osc_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Osc > (
    ::Osc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Osc >
Osc_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Osc > (
    ::Osc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Osc >
Osc_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Osc > (
    ::Osc_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Osc >
Osc_ (const ::xercesc::DOMDocument& doc,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Osc > (
      ::Osc_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Osc" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Osc > r (
      ::xsd::cxx::tree::traits< ::Osc, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Osc",
    "");
}

::std::unique_ptr< ::Osc >
Osc_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Osc" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Osc > r (
      ::xsd::cxx::tree::traits< ::Osc, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Osc",
    "");
}

::std::unique_ptr< ::Voltage >
Voltage_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Voltage > (
    ::Voltage_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voltage >
Voltage_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Voltage > (
    ::Voltage_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voltage >
Voltage_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Voltage > (
    ::Voltage_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voltage >
Voltage_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Voltage_ (isrc, f, p);
}

::std::unique_ptr< ::Voltage >
Voltage_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Voltage_ (isrc, h, f, p);
}

::std::unique_ptr< ::Voltage >
Voltage_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Voltage_ (isrc, h, f, p);
}

::std::unique_ptr< ::Voltage >
Voltage_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Voltage_ (isrc, f, p);
}

::std::unique_ptr< ::Voltage >
Voltage_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Voltage_ (isrc, h, f, p);
}

::std::unique_ptr< ::Voltage >
Voltage_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Voltage_ (isrc, h, f, p);
}

::std::unique_ptr< ::Voltage >
Voltage_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Voltage > (
    ::Voltage_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voltage >
Voltage_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Voltage > (
    ::Voltage_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voltage >
Voltage_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Voltage > (
    ::Voltage_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voltage >
Voltage_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Voltage > (
      ::Voltage_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Voltage" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Voltage > r (
      ::xsd::cxx::tree::traits< ::Voltage, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Voltage",
    "");
}

::std::unique_ptr< ::Voltage >
Voltage_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Voltage" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Voltage > r (
      ::xsd::cxx::tree::traits< ::Voltage, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Voltage",
    "");
}

::std::unique_ptr< ::Outputs >
Outputs_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Outputs > (
    ::Outputs_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Outputs >
Outputs_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Outputs > (
    ::Outputs_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Outputs >
Outputs_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Outputs > (
    ::Outputs_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Outputs >
Outputs_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Outputs_ (isrc, f, p);
}

::std::unique_ptr< ::Outputs >
Outputs_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Outputs_ (isrc, h, f, p);
}

::std::unique_ptr< ::Outputs >
Outputs_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Outputs_ (isrc, h, f, p);
}

::std::unique_ptr< ::Outputs >
Outputs_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Outputs_ (isrc, f, p);
}

::std::unique_ptr< ::Outputs >
Outputs_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Outputs_ (isrc, h, f, p);
}

::std::unique_ptr< ::Outputs >
Outputs_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Outputs_ (isrc, h, f, p);
}

::std::unique_ptr< ::Outputs >
Outputs_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Outputs > (
    ::Outputs_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Outputs >
Outputs_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Outputs > (
    ::Outputs_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Outputs >
Outputs_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Outputs > (
    ::Outputs_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Outputs >
Outputs_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Outputs > (
      ::Outputs_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Outputs" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Outputs > r (
      ::xsd::cxx::tree::traits< ::Outputs, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Outputs",
    "");
}

::std::unique_ptr< ::Outputs >
Outputs_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Outputs" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Outputs > r (
      ::xsd::cxx::tree::traits< ::Outputs, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Outputs",
    "");
}

::std::unique_ptr< ::Parameter >
Parameter_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Parameter > (
    ::Parameter_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Parameter >
Parameter_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Parameter > (
    ::Parameter_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Parameter >
Parameter_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Parameter > (
    ::Parameter_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Parameter >
Parameter_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Parameter_ (isrc, f, p);
}

::std::unique_ptr< ::Parameter >
Parameter_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Parameter_ (isrc, h, f, p);
}

::std::unique_ptr< ::Parameter >
Parameter_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Parameter_ (isrc, h, f, p);
}

::std::unique_ptr< ::Parameter >
Parameter_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Parameter_ (isrc, f, p);
}

::std::unique_ptr< ::Parameter >
Parameter_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Parameter_ (isrc, h, f, p);
}

::std::unique_ptr< ::Parameter >
Parameter_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Parameter_ (isrc, h, f, p);
}

::std::unique_ptr< ::Parameter >
Parameter_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Parameter > (
    ::Parameter_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Parameter >
Parameter_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Parameter > (
    ::Parameter_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Parameter >
Parameter_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Parameter > (
    ::Parameter_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Parameter >
Parameter_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Parameter > (
      ::Parameter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Parameter" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Parameter > r (
      ::xsd::cxx::tree::traits< ::Parameter, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Parameter",
    "");
}

::std::unique_ptr< ::Parameter >
Parameter_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Parameter" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Parameter > r (
      ::xsd::cxx::tree::traits< ::Parameter, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Parameter",
    "");
}

::std::unique_ptr< ::Voice >
Voice_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Voice > (
    ::Voice_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voice >
Voice_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Voice > (
    ::Voice_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voice >
Voice_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Voice > (
    ::Voice_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voice >
Voice_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Voice_ (isrc, f, p);
}

::std::unique_ptr< ::Voice >
Voice_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Voice_ (isrc, h, f, p);
}

::std::unique_ptr< ::Voice >
Voice_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Voice_ (isrc, h, f, p);
}

::std::unique_ptr< ::Voice >
Voice_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Voice_ (isrc, f, p);
}

::std::unique_ptr< ::Voice >
Voice_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Voice_ (isrc, h, f, p);
}

::std::unique_ptr< ::Voice >
Voice_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Voice_ (isrc, h, f, p);
}

::std::unique_ptr< ::Voice >
Voice_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Voice > (
    ::Voice_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voice >
Voice_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Voice > (
    ::Voice_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voice >
Voice_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Voice > (
    ::Voice_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Voice >
Voice_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Voice > (
      ::Voice_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Voice" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Voice > r (
      ::xsd::cxx::tree::traits< ::Voice, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Voice",
    "");
}

::std::unique_ptr< ::Voice >
Voice_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Voice" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Voice > r (
      ::xsd::cxx::tree::traits< ::Voice, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Voice",
    "");
}

::std::unique_ptr< ::Instrument >
Instrument_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Instrument > (
    ::Instrument_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instrument >
Instrument_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Instrument > (
    ::Instrument_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instrument >
Instrument_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Instrument > (
    ::Instrument_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instrument >
Instrument_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instrument_ (isrc, f, p);
}

::std::unique_ptr< ::Instrument >
Instrument_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instrument_ (isrc, h, f, p);
}

::std::unique_ptr< ::Instrument >
Instrument_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instrument_ (isrc, h, f, p);
}

::std::unique_ptr< ::Instrument >
Instrument_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instrument_ (isrc, f, p);
}

::std::unique_ptr< ::Instrument >
Instrument_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instrument_ (isrc, h, f, p);
}

::std::unique_ptr< ::Instrument >
Instrument_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instrument_ (isrc, h, f, p);
}

::std::unique_ptr< ::Instrument >
Instrument_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Instrument > (
    ::Instrument_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instrument >
Instrument_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Instrument > (
    ::Instrument_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instrument >
Instrument_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Instrument > (
    ::Instrument_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instrument >
Instrument_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Instrument > (
      ::Instrument_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Instrument" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Instrument > r (
      ::xsd::cxx::tree::traits< ::Instrument, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Instrument",
    "");
}

::std::unique_ptr< ::Instrument >
Instrument_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Instrument" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Instrument > r (
      ::xsd::cxx::tree::traits< ::Instrument, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Instrument",
    "");
}

::std::unique_ptr< ::Instruments >
Instruments_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Instruments > (
    ::Instruments_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instruments >
Instruments_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Instruments > (
    ::Instruments_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instruments >
Instruments_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Instruments > (
    ::Instruments_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instruments >
Instruments_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instruments_ (isrc, f, p);
}

::std::unique_ptr< ::Instruments >
Instruments_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instruments_ (isrc, h, f, p);
}

::std::unique_ptr< ::Instruments >
Instruments_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instruments_ (isrc, h, f, p);
}

::std::unique_ptr< ::Instruments >
Instruments_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instruments_ (isrc, f, p);
}

::std::unique_ptr< ::Instruments >
Instruments_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instruments_ (isrc, h, f, p);
}

::std::unique_ptr< ::Instruments >
Instruments_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instruments_ (isrc, h, f, p);
}

::std::unique_ptr< ::Instruments >
Instruments_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Instruments > (
    ::Instruments_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instruments >
Instruments_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Instruments > (
    ::Instruments_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instruments >
Instruments_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Instruments > (
    ::Instruments_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Instruments >
Instruments_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Instruments > (
      ::Instruments_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Instruments" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Instruments > r (
      ::xsd::cxx::tree::traits< ::Instruments, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Instruments",
    "");
}

::std::unique_ptr< ::Instruments >
Instruments_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Instruments" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Instruments > r (
      ::xsd::cxx::tree::traits< ::Instruments, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Instruments",
    "");
}

::std::unique_ptr< ::Layout >
Layout_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Layout > (
    ::Layout_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Layout >
Layout_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Layout > (
    ::Layout_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Layout >
Layout_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Layout > (
    ::Layout_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Layout >
Layout_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Layout_ (isrc, f, p);
}

::std::unique_ptr< ::Layout >
Layout_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Layout_ (isrc, h, f, p);
}

::std::unique_ptr< ::Layout >
Layout_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Layout_ (isrc, h, f, p);
}

::std::unique_ptr< ::Layout >
Layout_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Layout_ (isrc, f, p);
}

::std::unique_ptr< ::Layout >
Layout_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Layout_ (isrc, h, f, p);
}

::std::unique_ptr< ::Layout >
Layout_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Layout_ (isrc, h, f, p);
}

::std::unique_ptr< ::Layout >
Layout_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Layout > (
    ::Layout_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Layout >
Layout_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Layout > (
    ::Layout_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Layout >
Layout_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Layout > (
    ::Layout_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Layout >
Layout_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Layout > (
      ::Layout_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Layout" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Layout > r (
      ::xsd::cxx::tree::traits< ::Layout, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Layout",
    "");
}

::std::unique_ptr< ::Layout >
Layout_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Layout" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Layout > r (
      ::xsd::cxx::tree::traits< ::Layout, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Layout",
    "");
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::ControlSurfaces > (
    ::ControlSurfaces_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::ControlSurfaces > (
    ::ControlSurfaces_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::ControlSurfaces > (
    ::ControlSurfaces_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ControlSurfaces_ (isrc, f, p);
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ControlSurfaces_ (isrc, h, f, p);
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ControlSurfaces_ (isrc, h, f, p);
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ControlSurfaces_ (isrc, f, p);
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ControlSurfaces_ (isrc, h, f, p);
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ControlSurfaces_ (isrc, h, f, p);
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::ControlSurfaces > (
    ::ControlSurfaces_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::ControlSurfaces > (
    ::ControlSurfaces_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::ControlSurfaces > (
    ::ControlSurfaces_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::ControlSurfaces > (
      ::ControlSurfaces_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "ControlSurfaces" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::ControlSurfaces > r (
      ::xsd::cxx::tree::traits< ::ControlSurfaces, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ControlSurfaces",
    "");
}

::std::unique_ptr< ::ControlSurfaces >
ControlSurfaces_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "ControlSurfaces" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::ControlSurfaces > r (
      ::xsd::cxx::tree::traits< ::ControlSurfaces, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ControlSurfaces",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

