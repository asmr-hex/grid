/**
 * @file   engine
 * @brief  engine header
 * @author coco
 * @date   2021-07-23
 *************************************************/


#ifndef OPR_MODULES_H
#define OPR_MODULES_H

#include <map>
#include <vector>
#include <string>

#include "rx.hpp"

namespace opr {

  // TODO put these in some common types header.
  struct tick_t {};

  typedef unsigned int step_idx_t;
  typedef unsigned int ppqn_t;

  typedef unsigned short step_data_id_t;

  enum class protocol { Midi, Osc, Voltage };

  namespace module {

    /// @brief base virtual? class for all modules.
    // class Module {
    // };

   template <typename T>
   class Sequence {
   public:
     typedef std::vector<T> data_t;
     typedef std::map<step_data_id_t, data_t> step_t;
     typedef std::map<step_idx_t, step_t> sequence_t;
     rx::observable<T> events();
     rx::observable<T> added();
     rx::observable<T> removed();
     Sequence() = default;
     Sequence(sequence_t);
     void sync(rx::observable<step_idx_t>);
     void unsync();
     int size();
     data_t at(step_idx_t) noexcept;
     data_t at(step_idx_t, step_data_id_t) noexcept;
     data_t at(step_idx_t, const std::vector<step_data_id_t>&) noexcept;
     step_t operator[](step_idx_t); // honestly, do we need this?
     step_t& operator[](step_idx_t) const; // honestly, do we need this?
     void insert(step_idx_t, step_t);
     void merge(step_idx_t, step_t);
     void clear();
     void clear(step_idx_t);
     void clear(step_idx_t, step_data_id_t);
   private:
     rx::subject<T> events_subj;
     rx::subject<T> added_subj;
     rx::subject<T> removed_subj;
     rx::subscription subscription;
     sequence_t sequence;
   };

    /// @brief Sequencer Module.
    ///
    /// @details This module is a multi-voice, polyphonic, step sequencer.
    /// Each voice is routed to an
    class Sequencer {
    public:
      Sequencer();

      struct Clock {
        Clock(Sequencer&);
        void sync(std::string, rx::observable<tick_t>);
        void unsync(std::string);
        std::vector<std::string> list();
      private:
        Sequencer& sequencer;
        rx::subscription subscription;
        rx::observable<tick_t> observable;
        std::map<std::string, rx::observable<tick_t>> clocks;
        void subscribe();
      };

      struct Step {
        rx::behavior<step_idx_t> current = rx::behavior<step_idx_t>(0);
        rx::behavior<step_idx_t> last    = rx::behavior<step_idx_t>(8);
        rx::behavior<ppqn_t>     stride  = rx::behavior<step_idx_t>(1);
      };

      struct Playback {
        rx::behavior<bool> playing = rx::behavior<bool>(false);
        rx::behavior<bool> stopped = rx::behavior<bool>(true);
        rx::behavior<bool> paused  = rx::behavior<bool>(false);
      };

      // TODO add Randomization
      // TODO add complex periodic stride patterns

      Step     step;
      Clock    clock;
      Playback playback;

      void play();
      void stop();
      void pause();
    };

    template <protocol T>
    class Output {
    public:
    };

    template<>
    class Output<protocol::Midi> {
    public:
    };

    #include "modules_sequence.tpp"
    #include "modules_output.tpp"
  }
}

#endif
