/**
 * @file   engine
 * @brief  engine header
 * @author coco
 * @date   2021-07-23
 *************************************************/


#ifndef OPR_MODULES_H
#define OPR_MODULES_H

#include <map>
#include <vector>
#include <string>

#include "rx.hpp"

namespace opr {

  // TODO put these in some common types header.
  struct tick_t {};

  typedef unsigned int step_idx_t;
  typedef unsigned int ppqn_t;


  namespace module {

    /// @brief base virtual? class for all modules.
    // class Module {
    // };


    // class MemoryBlock {

    // };

    /// @brief Sequence Module.
    ///
    /// @details This module is a basic building block which provides
    /// sequential addressable memory. The contents of the memory can be
    /// anything from Midi Events, OSC Events, CV Events, or even program
    /// instructions! TODO (impl as a template class?)
    /// This allows this class to not just be a sequence, but more flexible
    /// like the tape on a turing machine...
    ///
    /// IMPORTANT: has no concept of time dynamics-- no current pointer, literally
    /// just sequential address space with a length.
    // class Sequence {
    //   void insert(); // TODO make this accept the template type
    // };

    /// @brief Sequencer Module.
    ///
    /// @details This module is a multi-voice, polyphonic, step sequencer.
    /// Each voice is routed to an
    ///
    /// inputs (per voice????): clocks, start/stop/pause, insert, delete, set last step, change ppqn (stride)
    ///
    /// questions: for Modules built on smaller modules...do we expose the interface for
    /// the smaller components?.....a reminder: continue thinking about it like modular
    /// synthesis-- expose the relevant apis from the encapsulating module.
    /// REMEMBER: these modules are MEANT to be composed! (composition over inheritance)
    /// AND larger modular systems are to be constructed from these modules....so in the
    /// app binary...we can construct the larger systems! EACH module should be able to
    /// serve its purpose independently!
    ///
    /// EACH VOICE gets its own sequencer.
    /// but what does voice mean....scenarios:
    ///  * (mono) pad-based instrument (drum machine e.g.)where each pad is its own voice (sequencer) because it should have its own clock, stride
    ///  * (poly) keyboard-based instrument where each note is its own pitch of the same voice. are there circumstances in which we would like to treat different pitches as different sequencers?
    ///  * parameter based sequences (cv/gate/toggle, midi cc, osc)
    ///  * instructions -- what does it mean to have instructions as a sequence....????
    ///
    ///
    /// input - tick
    /// output - index
    /// parameters - playback_state, stride (ppqn), last step, current step,
    class Sequencer {
    public:
      Sequencer();

      struct Clock {
        Clock(Sequencer&);
        void sync(std::string, rx::observable<tick_t>);
        void unsync(std::string);
        std::vector<std::string> list();
      private:
        Sequencer& sequencer;
        rx::subscription subscription;
        rx::observable<tick_t> observable;
        std::map<std::string, rx::observable<tick_t>> clocks;
        void subscribe();
      };

      struct Step {
        rx::behavior<step_idx_t> current = rx::behavior<step_idx_t>(0);
        rx::behavior<step_idx_t> last    = rx::behavior<step_idx_t>(8);
        rx::behavior<ppqn_t>     stride  = rx::behavior<step_idx_t>(1);
      };

      struct Playback {
        rx::behavior<bool> playing = rx::behavior<bool>(false);
        rx::behavior<bool> stopped = rx::behavior<bool>(true);
        rx::behavior<bool> paused  = rx::behavior<bool>(false);
      };

      // TODO add Randomization
      // TODO add complex periodic stride patterns

      Step     step;
      Clock    clock;
      Playback playback;

      void play();
      void stop();
      void pause();
    };
  }
}

#endif
